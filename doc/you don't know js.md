## you don't know js
>第一章：作用域是什么？

* 1、编译原理：主要分为三个步骤。
  * 分词/词法分析：这个过程会将字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元，例如，var=2，这段程序通常被分解为：var、a、=、2、这些词法单元。
  * 解析/语法分析：这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表语法结构的树，这个树被称为抽象语法树。
  * 代码生成：将var=2；的AST转化为一组机器指令，用来创建一个叫做a的变量（包括分配内存等），并将一个值存储在a中。
  
* 2、理解作用域。
  * 引擎：从头到尾负责整个javascript程序的编译以及执行过程。
  * 编译器：引擎的好朋友之一，负责语法分析及代码生成等脏活累活。
  * 作用域：引擎的另外一位好朋友，负责收集并维护由所有声明的变量组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
  
* 3、作用域是一套规则，如果查找的目的是为了对变量进行赋值，那么就会使用LHS查询，如果目的是为了获取变量的值，就会使用RHS查询。

* 4、不成功的RHS引用会导致抛出"ReferenceError"异常。不成功的LHR引用会导致自动隐式的创建一个全局变量（非严格模式下），严格模式下出"ReferenceError"异常

>第二章：词法作用域

* 1、作用域查找会在找到第一个匹配的标识符时停止，在多层的嵌套作用域中可以定义同名标识符，这叫做“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的变量为止。
* 2、javascript中有两个机制可以“欺骗”词法作用域：eval（...）和with。

>第三章：函数作用域和块作用域。

* 1、“隐藏”作用域中的变量和函数可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。
* 2、在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容
  
  var a = 2
   function foo (){ //添加这一行
     var a = 3;
     console.log(a); //3
   
    } //以及这一行
    foo(); //以及这一行
    console.log(a); //2
  
 * 3、区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
 * 4、 由于函数被包含在一对（）内部，因此成了一个函数表达式，通过在末尾加上一个（）可以立即执行这个函数，比如（function foo(){...})()。第一个（）将函数变成表达式，第二个（）执行了这个函数。
 * 5、let关键字是除var以外的另一种变量声明的方式。let关键字可以将变量绑定到所在的任意作用域中（通常是{...}内部）。换句话说，let为其声明的变量隐式地了所在的块作用域。
 * 6、let循环：一个let可以发挥优势的典型例子就是之前讨论的for循环。
 ```js
    for（let i=0; i<10 i++）{
        console.log(i);
        }
       console.log(i); //ReferenceError
       ```
  for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。
  下面通过另一种方式来说明每次迭代时进行重新绑定的行为。
  
  ```js
     {
         let j;
         for(j=0;j<10;j++){
             let i =j; //每个迭代重新绑定！
             console.log(i);
             }
     }
     ```
  * 7、ES6中引入的const同样可以用来声明变量，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。
 例如：
 
 ```js
      var foo = true;
      if (foo){
            var a = 2;
            const b = 3; //包含在if中的块作用域常量
            
            a = 3; //正常
            b = 4；//错误
            }
       console.log(a); //3
       console.log(b); //referenceError
       ```

>第四章：提升
* 1、函数作用域和块作用域的行为是一样的，可总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。
* 2、先有蛋（声明）后有鸡（赋值）。函数声明会被提升，但包括函数表达式的赋值在内的赋值操作并不会提升。
* 3 、函数声明和变量声明都会被提升。但是一个值得注意的细节是函数首先会被提升，然后才是变量。



 
